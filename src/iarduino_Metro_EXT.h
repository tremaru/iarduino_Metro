																														//
#ifndef iarduino_Metro_EXT_h																							//	Функции работы с датчиком света (Digital Sensor Light).
#define iarduino_Metro_EXT_h																							//
																														//
class iarduino_Metro_EXT: public iarduino_Metro_BASE{																	//	Определяем производный класс iarduino_Metro_EXT.
	public:																												//
	/**	функции данного производного класса iarduino_Metro_EXT		**/													//
	/**	дублирую функции полиморфного класса iarduino_Metro_BASE	**/													//
																														//
//		Функции не используемые в данном модуле:																		//
		bool	begin			(int i0=NOT2, int i1=NOT2	){return 0;}												//	Инициализация модуля.
		int		test			(int i0=NOT2, int i1=NOT2	){return 0;}												//	Самотестирование модуля.
																														//
//		Выполняем действия:																								//
		bool	action			(int i0=NOT2, int i1=NOT2	){															//	Объявляем функцию выполнения действий.
								uint8_t data[8] = {0,0,0,0,0,0,0,0};													//	Определяем массив для хранения данных пакетно считываемых/записываемых в модуль.
								bool	flgMode = false;																//	Определяем флаг указывающий на необходимость переконфигурирования выводов.
								bool    result  = false;																//	Определяем флаг результата возвращаемый функцией action.
								uint8_t sumtry  = 100;																	//	Количество попыток.
								uint8_t min=0, max=3; if(ext_pinNum<4){min=max=ext_pinNum;}								//	Определяем минимальный и максимальный номер вывода.
							//	Считываем конфигурацию всех выводов модуля в массив data:								//	
								do{	result	 =	iMetroI2C.readBytes( i1, REG_DATA, data, 6);							//	Читаем 6 байт из модуля с адресом i1, начиная с регистра REG_DATA в массив data.
									sumtry	--;	if(!result){delay(1);}													//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
								}	while		(!result && sumtry>0);													//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
								if(!result){return false;} result = false;												//	Если чтение неудачно, то возвращаем false.
								data[0] &= 0xF;																			//	Модуль метро использует только 4 младших бита байта конфигурации направления работы вывода.
								data[1] &= 0xF;																			//	Модуль метро использует только 4 младших бита байта конфигурации типа уровня вывода.
								data[2] &= 0xF;																			//	Модуль метро использует только 4 младших бита байта конфигурации подтягивающих резисторов.
								data[3] &= 0xF;																			//	Модуль метро использует только 4 младших бита байта конфигурации прижимающих резисторов.
								data[4] &= 0;																			//	Модуль метро использует только двухтактную схему работы выходов.
								switch(i0){																				//
								//	Действие № 0 - считать логический уровень с вывода ext_pinNum:						//
									case 0:																				//
										ext_pinLevel = 0;																//	Сбрасываем значение переменной хранящей читаемый/устанавливаемый уровень.
										for(uint8_t i=min; i<=max; i++){												//	Проходим по одному или всем выводам.
											if(  data[0] & bit(i)  ){ data[0] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем его как вход.
											if(  data[1] & bit(i)  ){ data[1] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем вывод как цифровой.
											if(  data[2] & bit(i)  ){ data[2] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости отключаем подтяжку.
											if(  data[3] & bit(i)  ){ data[3] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости отключаем прижатие.
										}																				//
										if( flgMode ){																	//	Если требуется переконфигурировать вывод, то ...
											do{	result = iMetroI2C.writeBytes( i1, REG_DATA, data, 4);					//	Записываем 4 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если запись неудачна, то возвращаем false.
										}																				//
										if( flgMode ){																	//	Если вывод был переконфигурирован, то ...
											data[0] = 0;																//	Готовим байт для получения данных.
											do{	result	 =	iMetroI2C.readBytes( i1, REG_DATA+5, data, 1);				//	Читаем 1 байт из модуля с адресом i1, начиная с регистра REG_DATA+5 в массив data.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если чтение неудачно, то возвращаем false.
										}else{																			//	Если вывод не переконфигурировался, то ...
											data[0]=data[5];															//	Байт лоогических состояний выводов уже находится в массиве data, просто перекладываем его в начало массива.
										}																				//
										ext_pinLevel = (ext_pinNum>3)?(data[0]&0x0F):((data[0]&bit(ext_pinNum))?1:0);	//	Результат чтения - один или 4 младших бита из полученного байта.
										return true;																	//	Возвращаем true.
									break;																				//
								//	Действие № 1 - считать лог. уровень подтянутого вывода ext_pinNum:					//
									case 1:																				//
										ext_pinLevel = 0;																//	Сбрасываем значение переменной хранящей читаемый/устанавливаемый уровень.
										for(uint8_t i=min; i<=max; i++){												//	Проходим по одному или всем выводам.
											if(  data[0] & bit(i)  ){ data[0] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем его как вход.
											if(  data[1] & bit(i)  ){ data[1] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем вывод как цифровой.
											if(!(data[2] & bit(i)) ){ data[2] |=  bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости используем подтяжку.
											if(  data[3] & bit(i)  ){ data[3] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости отключаем прижатие.
										}																				//
										if( flgMode ){																	//	Если требуется переконфигурировать вывод, то ...
											do{	result = iMetroI2C.writeBytes( i1, REG_DATA, data, 4);					//	Записываем 4 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если запись неудачна, то возвращаем false.
										}																				//
										if( flgMode ){																	//	Если вывод был переконфигурирован, то ...
											data[0] = 0;																//	Готовим байт для получения данных.
											do{	result	 =	iMetroI2C.readBytes( i1, REG_DATA+5, data, 1);				//	Читаем 1 байт из модуля с адресом i1, начиная с регистра REG_DATA+5 в массив data.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если чтение неудачно, то возвращаем false.
										}else{																			//	Если вывод не переконфигурировался, то ...
											data[0]=data[5];															//	Байт лоогических состояний выводов уже находится в массиве data, просто перекладываем его в начало массива.
										}																				//
										ext_pinLevel = (ext_pinNum>3)?(data[0]&0x0F):((data[0]&bit(ext_pinNum))?1:0);	//	Результат чтения - один или 4 младших бита из полученного байта.
										return true;																	//	Возвращаем true.
									break;																				//
								//	Действие № 2 - считать лог. уровень прижатого вывода ext_pinNum:					//
									case 2:																				//
										ext_pinLevel = 0;																//	Сбрасываем значение переменной хранящей читаемый/устанавливаемый уровень.
										for(uint8_t i=min; i<=max; i++){												//	Проходим по одному или всем выводам.
											if(  data[0] & bit(i)  ){ data[0] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем его как вход.
											if(  data[1] & bit(i)  ){ data[1] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости конфигурируем вывод как цифровой.
											if(  data[2] & bit(i)  ){ data[2] &= ~bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости отключаем подтяжку.
											if(!(data[3] & bit(i)) ){ data[3] |=  bit(i); flgMode=true; }				//	Проверяем конфигурацию вывода i и при необходимости используем прижатие.
										}																				//
										if( flgMode ){																	//	Если требуется переконфигурировать вывод, то ...
											do{	result = iMetroI2C.writeBytes( i1, REG_DATA, data, 4);					//	Записываем 4 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если запись неудачна, то возвращаем false.
										}																				//
										if( flgMode ){																	//	Если вывод был переконфигурирован, то ...
											data[0] = 0;																//	Готовим байт для получения данных.
											do{	result	 =	iMetroI2C.readBytes( i1, REG_DATA+5, data, 1);				//	Читаем 1 байт из модуля с адресом i1, начиная с регистра REG_DATA+5 в массив data.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если чтение неудачно, то возвращаем false.
										}else{																			//	Если вывод не переконфигурировался, то ...
											data[0]=data[5];															//	Байт лоогических состояний выводов уже находится в массиве data, просто перекладываем его в начало массива.
										}																				//
										ext_pinLevel = (ext_pinNum>3)?(data[0]&0x0F):((data[0]&bit(ext_pinNum))?1:0);	//	Результат чтения - один или 4 младших бита из полученного байта.
										return true;																	//	Возвращаем true.
									break;																				//
								//	Действие № 3 - считать аналоговый уровень с вывода ext_pinNum:						//
									case 3:																				//
										ext_pinLevel = 0;																//	Сбрасываем значение переменной хранящей читаемый/устанавливаемый уровень.
										if(ext_pinNum>3){return false;}													//	Проверяем корректность указания вывода.
										if(  data[0] & bit(ext_pinNum)  ){ data[0] &= ~bit(ext_pinNum); flgMode=true; }	//	Проверяем конфигурацию вывода ext_pinNum и при необходимости конфигурируем его как вход.
										if(!(data[1] & bit(ext_pinNum)) ){ data[1] |=  bit(ext_pinNum); flgMode=true; }	//	Проверяем конфигурацию вывода ext_pinNum и при необходимости конфигурируем вывод как аналоговый.
										if(  data[2] & bit(ext_pinNum)  ){ data[2] &= ~bit(ext_pinNum); flgMode=true; }	//	Проверяем конфигурацию вывода ext_pinNum и при необходимости отключаем подтяжку.
										if(  data[3] & bit(ext_pinNum)  ){ data[3] &= ~bit(ext_pinNum); flgMode=true; }	//	Проверяем конфигурацию вывода ext_pinNum и при необходимости отключаем прижатие.
										if( flgMode ){																	//	Если требуется переконфигурировать вывод, то ...
											do{	result = iMetroI2C.writeBytes( i1, REG_DATA, data, 4);					//	Записываем 4 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если запись неудачна, то возвращаем false.
			/*	Обязательная задержка	*/	delay(5);																	//	Выжидаем время для обновления данных АЦП модуля после переконфигурирования вывода.
										}																				//
										data[0] = data[1] = 0;															//	Готовим два байта для получения данных.
										do{	result	 =	iMetroI2C.readBytes( i1, REG_DATA+8+(ext_pinNum*2), data, 2);	//	Читаем 2 байта из модуля с адресом i1, начиная с регистра REG_DATA+8+(i*2) в массив data.
											sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);											//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										if(!result){return false;} result = false;										//	Если чтение неудачно, то возвращаем false.
										ext_pinLevel = data[1]; ext_pinLevel <<= 8; ext_pinLevel |= data[0];			//	Собираем два байта в одну переменную.
										return true;																	//	Возвращаем true.
									break;																				//
								//	Действие № 4 - установить логический уровень или ШИМ на выводе ext_pinNum:			//
									case 4:																				//
										for(uint8_t i=min; i<=max; i++){												//	Проходим по одному или всем выводам.
												if(!(data[0] & bit(i)) ){ data[0] |=  bit(i); flgMode=true; }			//	Проверяем конфигурацию вывода i и при необходимости конфигурируем его как выход.
											if( ext_pinType ){															//	Если устанавливается аналоговый уровень, то ...
												if(!(data[1] & bit(i)) ){ data[1] |=  bit(i); flgMode=true; }			//	Проверяем конфигурацию вывода i и при необходимости конфигурируем вывод как аналоговый.
											}else{																		//	Если устанавливается логический уровень, то ...
												if(  data[1] & bit(i)  ){ data[1] &= ~bit(i); flgMode=true; }			//	Проверяем конфигурацию вывода i и при необходимости конфигурируем вывод как цифровой.
											}	if(  data[2] & bit(i)  ){ data[2] &= ~bit(i); flgMode=true; }			//	Проверяем конфигурацию вывода i и при необходимости отключаем подтяжку.
												if(  data[3] & bit(i)  ){ data[3] &= ~bit(i); flgMode=true; }			//	Проверяем конфигурацию вывода i и при необходимости отключаем прижатие.
											if(!ext_pinType ){															//	Если устанавливаемый уровень является цифровым, то ...
												if(ext_pinLevel){         data[5] |=  bit(i); }							//	Устанавливаем высокий логический уровень.
												else            {         data[5] &= ~bit(i); }							//	Устанавливаем низкий  логический уровень.
											}																			//
										}																				//
										if(!ext_pinType ){																//	Если устанавливается логический уровень, то ...
											if(!flgMode ){																//	Если вывод не требуется переконфигурировать, то ...
												data[0]=data[5];														//	Будем записывать только один байт с уровнями.
											}																			//
											do{	result=iMetroI2C.writeBytes(i1,REG_DATA+(flgMode?0:5),data,flgMode?6:1);//	Записываем 6 (с конфигурированием) или 1 (без конфигурирования) элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA (с конфигурированием) или REG_DATA+5 (без конфигурирования).
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											return result;																//	На этом установка логических уровней завершена, возвращаем результат записи.
										}																				//
										if( flgMode ){																	//	Если вывод требуется переконфигурировать для установки аналогового уровня, то ...
											do{	result = iMetroI2C.writeBytes( i1, REG_DATA, data, 4);					//	Записываем 4 элемента массива data в модуль с адресом i1, начиная с регистра REG_DATA.
												sumtry	--;	if(!result){delay(1);}										//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
											}	while		(!result && sumtry>0);										//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
											if(!result){return false;} result = false;									//	Если запись неудачна, то возвращаем false.
			/*	Обязательная задержка	*/	delay(5);																	//	Выжидаем время для запуска таймера ШИМ модуля.
										}																				//
										if(ext_pinServo){																//	Если требуется управлять сервоприводом, то ...
											if(!flg_ServoPWM ){															//	Если частота ШИМ не изменена на 50 Гц, то ...
												data[0] = 50;															//	Готовим младший байт частоты ШИМ.
												data[1] = 0;															//	Готовим старший байт частоты ШИМ.
												do{	result = iMetroI2C.writeBytes( i1, REG_WRITE, data, 2);				//	Записываем 2 элемента массива data в модуль с адресом i1, начиная с регистра REG_WRITE.
													sumtry	--;	if(!result){delay(1);}									//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
												}	while		(!result && sumtry>0);									//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
												if(!result){return false;} result = false;								//	Если запись неудачна, то возвращаем false.
												flg_ServoPWM = true;													//	Устанавливаем флаг указывающий на то, что частота ШИМ изменена на 50 Гц для сервоприводов.
			/*	Задержка	*/					delay(5);																//	Выжидаем время для преобразования уже установленных коэффициентов заполнения ШИМ под новую частоту.
											}																			//
											if( ext_pinLevel>180 ){ ext_pinLevel=180; }									//	Работаем только с сервоприводами угол поворота которых от 0 до 180°
											if( ext_pinLevel<0   ){ ext_pinLevel=0;   }									//	Работаем только с сервоприводами угол поворота которых от 0 до 180°
											ext_pinLevel = map(ext_pinLevel, 0, 180, 500, 2500);						//	Преобразуем угол (°) в ширину импульсов (мкс).
											ext_pinLevel = int((double)ext_pinLevel*0.20475);							//	Преобразуем ширину импульсов (мкс) в коэффициент заполнения (ширина * 4095 / 20000 мкс, где 20000 мкс это период частоты в 50 Гц.)
										}																				//
										for(uint8_t i=min; i<=max; i++){												//	Проходим по одному или всем выводам.
											data[(max>min?(i*2):0)  ] =  ext_pinLevel     & 0x00FF;						//	Готовим младший байт аналогового уровня для передачи в модуль.
											data[(max>min?(i*2):0)+1] = (ext_pinLevel>>8) & 0x000F;						//	Готовим старший байт аналогового уровня для передачи в модуль.
										}																				//
										do{	result = iMetroI2C.writeBytes( i1, REG_DATA+8+(min*2), data, max>min?8:2);	//	Записываем 2 или 8 элементов массива data в модуль с адресом i1, начиная с регистра REG_DATA+8+(min*2).
											sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
										return result;																	//	На этом установка аналоговых уровней завершена, возвращаем результат записи.
									break;																				//
								//	Действие № 5 - установить частоту ШИМ:												//
									case 5:																				//
										if(ext_pinLevel<1    ){ext_pinLevel=1;    }										//
										if(ext_pinLevel>12000){ext_pinLevel=12000;}										//
										data[0] =  uint16_t(ext_pinLevel)     & 0x00FF;									//	Готовим младший байт частоты ШИМ.
										data[1] = (uint16_t(ext_pinLevel)>>8) & 0x00FF;									//	Готовим старший байт частоты ШИМ.
										do{	result = iMetroI2C.writeBytes( i1, REG_WRITE, data, 2);						//	Записываем 2 элемента массива data в модуль с адресом i1, начиная с регистра REG_WRITE.
											sumtry	--;	if(!result){delay(1);}											//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);											//	Повторяем запись если она завершилась неудачей, но не более sumtry попыток.
			/*	Задержка	*/			if(result){flg_ServoPWM=false; delay(5);}										//	Если запись успешна, то сбрасываем флаг flg_ServoPWM указывающий на то, что частота ШИМ изменена на 50 Гц для сервоприводов.
										return result;																	//	На этом установка частоты завершена, возвращаем результат записи.
									break;																				//
								}																						//
		}																												//
																														//
//		Получаем значение переменных:																					//
		void	setVar			(int i0=NOT2, int i1=NOT2	){															//
								switch(i0){																				//
									case 0: ext_pinNum   = i1; break;													//	Получаем номер вывода для чтения/записи.
									case 1: ext_pinLevel = i1; break;													//	Получаем уровень для установки на выводе.
									case 2:							 ext_pinType = false; ext_pinServo=false;			//	Получаем тип устанавливаемого уровня:
											if( i1==EXT_SERVO  )	{ext_pinType = true;  ext_pinServo=true; }			//	Управление сервоприводами.
											if( i1==EXT_ANALOG )	{ext_pinType = true;}								//	Установка сигнала ШИМ.
								}																						//
		}																												//
																														//
//		Возвращаем значение переменных:																					//
		long	getVar			(int i0=NOT2){																			//
								switch(i0){																				//
									case 0:						  return long(ext_pinLevel);	break;					//	Возвращаем значение считанного уровня ext_pinLevel с вывода ext_pinNum.
									default:					  return 0;						break;					//
								}																						//
		}																												//
																														//
	private:																											//
	/**	Внутренние переменные **/																						//
		int			ext_pinNum;																							//	Объявляем переменную для хранения номера вывода для чтения/записи уровня ext_pinLevel.
		int			ext_pinLevel;																						//	Объявляем переменную для хранения читаемого/устанавливаемого уровня вывода ext_pinNum.
		bool		ext_pinType;																						//	Объявляем флаг для хранения типа устанавливаемого уровня на выводе ext_pinNum (0-цифровой,1-аналоговый).
		bool		ext_pinServo;																						//	Объявляем флаг указывающий на управление сервоприводом (0-нет,1-да).
		bool		flg_ServoPWM = false;																				//	Флаг указывающий на то, что частота ШИМ изменена на 50 Гц для сервоприводов.
};																														//
																														//
#endif																													//

/* =======================================================================================================================================================================================================

Действия функций библиотеки:

read( вывод [, тип уровня ] )            - считывает уровень с вывода (тип уровня по умолчанию EXT_DIGITAL):
      0...3  , EXT_DIGITAL               - вернуть логический уровень установленный на выводе (0 / 1).
      0...3  , EXT_ANALOG                - вернуть аналоговый уровень установленный на выводе (0...4095).
set(  вывод  , уровень [, тип уровня ] ) - устанавливает уровень на выводе (тип по умолчанию EXT_DIGITAL):
      0...3  , 0/1        EXT_DIGITAL    - установить логический уровень на выводе.
      0...3  , 0...4095   EXT_ANALOG     - установить аналоговый уровень на выводе.
      0...3  , 0...180    EXT_SERVO      - установить угол поворота сервопривода.
frequency(частота);                      - установить новую частоту ШИМ.
          1...12000

Таблица регистров модуля:

                   ╔══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤═════════════════════════════════════════════════════════════╗
                   ║       7      │       6      │       5      │       4      │       3      │       2      │       1      │       0      │                                                             ║
                   ╟══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪═════════════════════════════════════════════════════════════╣
0x00 REG_FLAGS_0   ║  FLG_RESET   │FLG_SELF_TEST │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x01 REG_BITS_0    ║  SET_RESET   │SET_SELF_TEST │       -      │       -      │       -      │       -      │ SAVE_ADR_EN  │       -      │ Служебные флаги для записи.                                 ║
0x02 REG_FLAGS_1   ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x03 REG_BITS_1    ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для записи.                                 ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x04 REG_MODEL   █ ║                                                             REG_MODEL  [7-0] = 0x07 - расширитель выводов             │ Тип датчика                                                 ║
0x05 REG_VERSION █ ║                                                             REG_VERSION[7-0] = 0x02                                   │ Версия прошивки                                             ║
0x06 REG_ADDRESS   ║                                                             REG_ADDRESS[6-0] = 0x09                    │  SAVE_FLASH  │ Текущий адрес на шине                                       ║
0x07 REG_CHIP_ID   ║                                                             REG_CHIP_ID[7-0] = 0x3C                                   │ ID линейки чипов Flash                                      ║
                   ╟───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────╢
0x08 REG_WRITE     ║                   1 -    500 Гц => 12 бит                   REG_FREQUENCY[7-0]   = 0xEA =>                            │ Частота ШИМ на аналоговых выходах в Гц (младший байт)       ║
0x09 REG_WRITE+1 █ ║                 501 -  1'000 Гц => 11 бит                   REG_FREQUENCY[15-8]  = 0x01 => 0x01EA = 490 Гц            │ Частота ШИМ на аналоговых выходах в Гц (старший байт)       ║ (значение применяется после записи старшего байта)
0x0A REG_WRITE+2 █ ║               1'001 -  3'000 Гц => 10 бит                   REG_LEVEL[7-0]       = 0xFF =>                            │ Значение срабатывания битов DIGITAL от аналоговых входов.   ║
0x0B REG_WRITE+3 █ ║               3'001 -  6'000 Гц =>  9 бит                   REG_LEVEL[11-8]      = 0x07 => 0x07FF = 50%               │ Значение срабатывания битов DIGITAL от аналоговых входов.   ║ (значение применяется после записи старшего байта)
0x0C REG_WRITE+4 █ ║               6'001 - 12'000 Гц =>  8 бит                   REG_HYSTERESIS[7-0]  = 0xCD =>                            │ Гистерезис между «REG_LEVEL» и уровнем аналогового входа.   ║
0x0D REG_WRITE+5 █ ║                                                             REG_HYSTERESIS[11-8] = 0x00 => 0x00CD ≈ ±5%               │ Гистерезис между «REG_LEVEL» и уровнем аналогового входа.   ║ (значение применяется после записи старшего байта)
0x0E REG_WRITE+6 █ ║                                                             REG_AVERAGING[7-0]   = 0x7F =  127                        │ Коэффициент усреднения показаний АЦП: 0-нет...255-макс.     ║
0x0F REG_WRITE+7   ║                                                             REG_WRITE_7[7-0]                                          │ Зарезервирован                                              ║
                   ╟──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┼─────────────────────────────────────────────────────────────╢
0x10 REG_DATA    █ ║    DIR_7     │    DIR_6     │    DIR_5     │    DIR_4     │    DIR_3     │    DIR_2     │    DIR_1     │    DIR_0     │ Направление работы вывода: 0-вход; 1-выход                  ║
0x11 REG_DATA+1  █ ║    TYPE_7    │    TYPE_6    │    TYPE_5    │    TYPE_4    │    TYPE_3    │    TYPE_2    │    TYPE_1    │    TYPE_0    │ Тип вывода: 0-логический; 1-аналоговый.                     ║
0x12 REG_DATA+2  █ ║   PULL_UP_7  │   PULL_UP_6  │   PULL_UP_5  │   PULL_UP_4  │   PULL_UP_3  │   PULL_UP_2  │   PULL_UP_1  │   PULL_UP_0  │ Включить внутренний подтягивающий резистор: 0-нет; 1-да.    ║
0x13 REG_DATA+3  █ ║  PULL_DOWN_7 │  PULL_DOWN_6 │  PULL_DOWN_5 │  PULL_DOWN_4 │  PULL_DOWN_3 │  PULL_DOWN_2 │  PULL_DOWN_1 │  PULL_DOWN_0 │ Включить внутренний прижимающий   резистор: 0-нет; 1-да.    ║
0x14 REG_DATA+4  █ ║    MODE_7    │    MODE_6    │    MODE_5    │    MODE_4    │    MODE_3    │    MODE_2    │    MODE_1    │    MODE_0    │ Режим работы схемы выхода: 0-двухтактная; 1-открытый сток.  ║ (не используется в данной библиотеке)
0x15 REG_DATA+5  █ ║   DIGITAL_7  │   DIGITAL_6  │   DIGITAL_5  │   DIGITAL_4  │   DIGITAL_3  │   DIGITAL_2  │   DIGITAL_1  │   DIGITAL_0  │ Чтение/запись логического уровня на выводе.                 ║
0x16 REG_DATA+6  █ ║ WRITE_HIGH_7 │ WRITE_HIGH_6 │ WRITE_HIGH_5 │ WRITE_HIGH_4 │ WRITE_HIGH_3 │ WRITE_HIGH_2 │ WRITE_HIGH_1 │ WRITE_HIGH_0 │ Установить логическую «1»: 0-игнорировать; 1-установить.    ║
0x17 REG_DATA+7  █ ║ WRITE_HIGH_7 │ WRITE_LOW_6  │ WRITE_LOW_5  │ WRITE_LOW_4  │ WRITE_LOW_3  │ WRITE_LOW_2  │ WRITE_LOW_1  │ WRITE_LOW_0  │ Установить логический «0»: 0-игнорировать; 1-установить.    ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x18 REG_DATA+8  █ ║                                                             REG_ANALOG_0[7-0]                                         │ Чтение/запись аналогового значения на выводе 0 (мл. байт).  ║
0x19 REG_DATA+9  █ ║                                                             REG_ANALOG_0[11-8]                                        │ Чтение/запись аналогового значения на выводе 0 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x1A REG_DATA+10 █ ║                                                             REG_ANALOG_1[7-0]                                         │ Чтение/запись аналогового значения на выводе 1 (мл. байт).  ║
0x1B REG_DATA+11 █ ║                                                             REG_ANALOG_1[11-8]                                        │ Чтение/запись аналогового значения на выводе 1 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x1C REG_DATA+12 █ ║                                                             REG_ANALOG_2[7-0]                                         │ Чтение/запись аналогового значения на выводе 2 (мл. байт).  ║
0x1D REG_DATA+13 █ ║                                                             REG_ANALOG_2[11-8]                                        │ Чтение/запись аналогового значения на выводе 2 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x1E REG_DATA+14 █ ║                                                             REG_ANALOG_3[7-0]                                         │ Чтение/запись аналогового значения на выводе 3 (мл. байт).  ║
0x1F REG_DATA+15 █ ║                                                             REG_ANALOG_3[11-8]                                        │ Чтение/запись аналогового значения на выводе 3 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x20 REG_DATA+16 █ ║                                                             REG_ANALOG_4[7-0]                                         │ Чтение/запись аналогового значения на выводе 4 (мл. байт).  ║
0x21 REG_DATA+17 █ ║                                                             REG_ANALOG_4[11-8]                                        │ Чтение/запись аналогового значения на выводе 4 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x22 REG_DATA+18 █ ║                                                             REG_ANALOG_5[7-0]                                         │ Чтение/запись аналогового значения на выводе 5 (мл. байт).  ║
0x23 REG_DATA+19 █ ║                                                             REG_ANALOG_5[11-8]                                        │ Чтение/запись аналогового значения на выводе 5 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x24 REG_DATA+20 █ ║                                                             REG_ANALOG_6[7-0]                                         │ Чтение/запись аналогового значения на выводе 6 (мл. байт).  ║
0x25 REG_DATA+21 █ ║                                                             REG_ANALOG_6[11-8]                                        │ Чтение/запись аналогового значения на выводе 6 (ст. байт).  ║ (значение применяется после записи старшего байта)
0x26 REG_DATA+22 █ ║                                                             REG_ANALOG_7[7-0]                                         │ Чтение/запись аналогового значения на выводе 7 (мл. байт).  ║
0x27 REG_DATA+23 █ ║                                                             REG_ANALOG_7[11-8]                                        │ Чтение/запись аналогового значения на выводе 7 (ст. байт).  ║ (значение применяется после записи старшего байта)
                   ╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╧═════════════════════════════════════════════════════════════╝

REG_FREQUENCY    - Частота ШИМ в Гц (от 1 до 12000).
REG_LEVEL        - Граница АЦП (от 0 до 4095) по которой устанавливаеются биты DIGITAL если их вывод сконфигурирован как аналоговый вход.
REG_HYSTERESIS   - Ширина нечувствительной зоны возле границы (±2047) созданной регистром REG_LEVEL.
REG_AVERAGING    - Коэффициент усреднения показаний АЦП (от 0 до 255).
DIR_X            - Биты определяющие направление работы вывода (0-вход, 1-выход).
TYPE_X           - Биты определяющие тип вывода (0-логический, 1-аналоговый).
PULL_UP_X        - Биты определяющие наличие подтягивающий резисторов (0-нет, 1-да).
PULL_DOWN_X      - Биты определяющие наличие прижимающих   резисторов (0-нет, 1-да).
MODE_X           - Биты определяющие схему включения выхода (0-двухтактная, 1-открытый сток).
DIGITAL_X        - Биты позволяющие  читать или записывать логические уровни на выводе.
WRITE_HIGH_X     - Биты позволяющие  установить логическую «1» (0-игнорировать, 1-установить).
WRITE_HIGH_X     - Биты позволяющие  установить логический «0» (0-игнорировать, 1-установить).
REG_ANALOG_X     - Двухбайтные регистры позволяющие читать или записывать аналоговые уровни (от 0 до 4095) на выводе.

*/
