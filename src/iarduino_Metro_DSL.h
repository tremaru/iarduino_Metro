																										//
#ifndef iarduino_Metro_DSL_h																			//	Функции работы с датчиком света (Digital Sensor Light).
#define iarduino_Metro_DSL_h																			//
																										//
class iarduino_Metro_DSL: public iarduino_Metro_BASE{													//	Определяем производный класс iarduino_Metro_DSL.
	public:																								//
	/**	функции данного производного класса iarduino_Metro_DSL		**/									//
	/**	дублирую функции полиморфного класса iarduino_Metro_BASE	**/									//
																										//
//		Функции не используемые в данном модуле:														//
		bool	begin			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Инициализация модуля.
		int		test			(int i0=NOT2, int i1=NOT2	){return 0;}								//	Самотестирование модуля.
																										//
//		Выполняем действия:																				//
		bool	action			(int i0=NOT2, int i1=NOT2	){											//	Объявляем функцию выполнения действий.
								uint8_t data[2] = {0,0};												//	Определяем массив для хранения данных пакетно считываемых/записываемых в модуль.
								bool    result  = false;												//	Определяем флаг результата возвращаемый функцией action.
								uint8_t sumtry  = 100;													//	Количество попыток.
								switch(i0){																//
								//	Действие № 0 - установить значение LUX_CHANGE:						//
									case 0:																//
										do{	result	 =	objI2C.writeByte( i1, REG_DATA+3, dsl_change );	//	Записываем значение dsl_change в регистр REG_DATA+3 модуля с адресом i1.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток записи и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем запись если она завершилось неудачей, но не более sumtry попыток.
									break;																//
								//	Действие № 1 - прочитать значение освещённости:						//
									case 1:																//
										do{	result	 =	objI2C.readBytes( i1, REG_DATA+1, data, 2);		//	Читаем 2 байта из модуля с адресом i1, начиная с регистра REG_DATA+1 в массив data.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										dsl_result		 =			data[1];							//	Сохраняем старший байт значения освещённости.
										dsl_result		<<=			8;									//	Сдвигаем значение старшего байта на 8 бит влево.
										dsl_result		+=			data[0];							//	Сохраняем младший байт значения освещённости.
									//	Устранение ложных пиков в показаниях датчика:					//
										if(dsl_result>8191)			{dsl_result=dsl_lux_last;}			//	Показания не должны превышать 8191 лк.
										else						{dsl_lux_last=dsl_result;}			//	Если освещённость ниже 8191 лк, то сохраняем её для следующего не корректного показания.
									break;																//
								//	Действие № 2 - прочитать флаг изменения освещённости на dsl_change:	//
									case 2:																//
										do{	result	 =	objI2C.readBytes( i1, REG_DATA, data, 1);		//	Читаем 1 байт из модуля с адресом i1, начиная с регистра REG_DATA в массив data.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										dsl_result	=	(data[0] & bit(0))?1:0;							//	Сохраняем младший бит прочитанного байта.
									break;																//
								//	Действие № 3 - прочитать уровень близости препятствия:				//
									case 3:																//
										do{	result	 =	objI2C.readBytes( i1, REG_DATA+5, data, 2);		//	Читаем 2 байта из модуля с адресом i1, начиная с регистра REG_DATA+5 в массив data.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										dsl_result		 =			data[1];							//	Сохраняем старший байт уровня близости препятствия.
										dsl_result		<<=			8;									//	Сдвигаем значение старшего байта на 8 бит влево.
										dsl_result		+=			data[0];							//	Сохраняем младший байт уровня близости препятствия.
										dsl_result		/=			100;								//	Преобразуем значение от диапазона 0...1023 к диапазону 0...10.
									//	Устранение ложных показаний:									//
										if(dsl_result>10)			{dsl_result=10;}					//	Показания не должны превышать значение 10.
									break;																//
								//	Действие № 4 - прочитать коэффициент пульсаций источника света:		//
									case 4:																//
										do{	result	 =	objI2C.readBytes( i1, REG_DATA+4, data, 1);		//	Читаем 1 байт из модуля с адресом i1, начиная с регистра REG_DATA+4 в массив data.
											sumtry	--;	if(!result){delay(1);}							//	Уменьшаем количество попыток чтения и устанавливаем задержку при неудаче.
										}	while		(!result && sumtry>0);							//	Повторяем чтение если оно завершилось неудачей, но не более sumtry попыток.
										dsl_result		=			data[0];							//	Сохраняем байт коэффициента пульсаций источника света.
									//	Устранение ложных показаний:									//
										if(dsl_result>100)			{dsl_result=100;}					//	Показания не должны превышать 100%.
									break;																//
								}																		//
								return result;															//
		}																								//
																										//
//		Получаем значение переменных:																	//
		void	setVar			(int i0=NOT2, int i1=NOT2	){											//
								switch(i0){																//
									case 0: dsl_change = i1; break;										//	Получаем значение освещённости в лк, при изменении на которое установится флаг CHANGED: 1 ... 255.
								}																		//
		}																								//
																										//
//		Возвращаем значение переменных:																	//
		long	getVar			(int i0=NOT2){ return long(dsl_result); }								//	Возвращаем результат.
																										//
	private:																							//
	/**	Внутренние переменные **/																		//
		uint16_t	dsl_result;																			//	Объявляем переменную для хранения возвращаемого значения.
		uint16_t	dsl_lux_last;																		//	Объявляем переменную для хранения предыдущего значения освещённости
		uint8_t		dsl_change;																			//	Объявляем переменную для хранения значения АЦП, при изменении на которое установится флаг CHANGED.
};																										//
																										//
#endif																									//

/* =======================================================================================================================================================================================================

Действия функций библиотеки:

read( [ параметр     ] )               - считывает требуемые данные (по умолчанию DSL_LUX):
        DSL_LUX                        - вернуть значение освещённости в лк снятое с датчика света (от 0 до 8191).
        DSL_CHANGED                    - вернуть флаг CHANGED регистра REG_DATA.
        DSL_DISTANCE                   - вернуть уровень близости препятствия (от 0 до 10) чем выше значение, тем ближе препятствие.
set( чувствительность )                - установка чувствительности для срабатывания флага CHANGED. Чувствительность указывается в лк от 1 до 255.

Таблица регистров модуля:

                   ╔══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤══════════════╤═════════════════════════════════════════════════════════════╗
                   ║       7      │       6      │       5      │       4      │       3      │       2      │       1      │       0      │                                                             ║
                   ╠══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪══════════════╪═════════════════════════════════════════════════════════════╣
0x00 REG_FLAGS_0   ║  FLG_RESET   │FLG_SELF_TEST │       -      │       -      │       -      │       -      │GET_PIN_ADDRES│GET_PIN_OUTPUT│ Служебные флаги для чтения.                                 ║
0x01 REG_BITS_0    ║  SET_RESET   │SET_SELF_TEST │       -      │       -      │       -      │       -      │       -      │SET_PIN_OUTPUT│ Служебные флаги для записи.                                 ║
0x02 REG_FLAGS_1   ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для чтения.                                 ║
0x03 REG_BITS_1    ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │       -      │ Служебные флаги для записи.                                 ║
                   ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x04 REG_MODEL   █ ║                                                             MODEL  [7-0] = 0x06 - датчик света                        │ Тип датчика                                                 ║
0x05 REG_VERSION   ║                                                             VERSION[7-0] = 0x00                                       │ Версия прошивки                                             ║
0x06 REG_ADDRESS   ║                                                             ADDRESS[6-0] = 0x09                        │ IF_PIN_ADDRES│ Текущий адрес на шине                                       ║
0x07 REG_CHIP_ID   ║                                                             CHIP_ID[7-0] = 0xC3                                       │ ID линейки чипов                                            ║
                   ╟───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────╢
0x08 REG_WRITE     ║                                                             WRITE_0[7-0]                                              │ Зарезервирован                                              ║
0x09 REG_WRITE+1   ║                                                             WRITE_1[7-0]                                              │ Зарезервирован                                              ║
0x0A REG_WRITE+2   ║                                                             WRITE_2[7-0]                                              │ Зарезервирован                                              ║
0x0B REG_WRITE+3   ║                                                             WRITE_3[7-0]                                              │ Зарезервирован                                              ║
0x0C REG_WRITE+4   ║                                                             WRITE_4[7-0]                                              │ Зарезервирован                                              ║
0x0D REG_WRITE+5   ║                                                             WRITE_5[7-0]                                              │ Зарезервирован                                              ║
0x0E REG_WRITE+6   ║                                                             WRITE_6[7-0]                                              │ Зарезервирован                                              ║
0x0F REG_WRITE+7   ║                                                             WRITE_7[7-0]                                              │ Зарезервирован                                              ║
                   ╟──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┬──────────────┼─────────────────────────────────────────────────────────────╢
0x10 REG_DATA;   █ ║       -      │       -      │       -      │       -      │       -      │       -      │       -      │   CHANGED    │ Статусные флаги                                             ║
                 █ ╟──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┴──────────────┼─────────────────────────────────────────────────────────────╢
0x11 REG_DATA+1  █ ║                                                             LUX[7-0]                                                  │ Значение освещённости снятое с датчика света (младший байт) ║
0x12 REG_DATA+2  █ ║                                                             LUX[15-8]                                                 │ Значение освещённости снятое с датчика света (старший байт) ║
0x13 REG_DATA+3  █ ║                                                             LUX_CHANGE[7-0] = 0x64 = 100 лк из 255 лк                 │ Если LUX изм. более чем на LUX_CHANGE то установится CHANGED║
0x14 REG_DATA+4  █ ║                                                             REG_COEFFICIENT[7-0]                                      │ Коэффициент пульсаций света в процентах (0...100%).         ║
0x15 REG_DATA+5  █ ║                                                             REG_PROXIMITY[7-0]                                        │ Значение усреднённого расстояния (младшие биты).            ║
0x16 REG_DATA+6  █ ║                                                             REG_PROXIMITY[15-8]                                       │ Значение усреднённого расстояния (старшие биты).            ║
                   ╚═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╧═════════════════════════════════════════════════════════════╝
				   
CHANGED          - флаг указывает на то, что освещённость «LUX» изменились на более чем «LUX_CHANGE» значений с момента последней установки флага «CHANGED». Флаг сбрасывается аппаратно после чтения регистра REG_DATA.
LUX				 - Значение освещённости (в лк) снятое с датчика света (от 0 до 8191).
LUX_CHANGE       - Значение (от 1 до 255 лк), при изменении освещённости «LUX» на которое, установится флаг CHANGED.
REG_COEFFICIENT  - Коэффициент пульсаций света в процентах (0...100%).
REG_PROXIMITY    - Уровень близости препятствия (от 0 до 1023).

*/